<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no" />
        <meta name="description" content="" />
        <meta name="author" content="" />
        <title>Meng MAE4190 Lab Portfolio</title>
        <!-- Favicon-->
        <link rel="icon" type="image/x-icon" href="assets/favicon.ico" />
        <!-- Font Awesome icons (free version)-->
        <script src="https://use.fontawesome.com/releases/v6.3.0/js/all.js" crossorigin="anonymous"></script>
        <!-- Google fonts-->
        <link href="https://fonts.googleapis.com/css?family=Montserrat:400,700" rel="stylesheet" type="text/css" />
        <link href="https://fonts.googleapis.com/css?family=Lato:400,700,400italic,700italic" rel="stylesheet" type="text/css" />
        <!-- Core theme CSS (includes Bootstrap)-->
        <link href="css/styles.css" rel="stylesheet" />
    </head>
    <body id="page-top">
        <!-- Navigation-->
        <nav class="navbar navbar-expand-lg bg-secondary text-uppercase fixed-top" id="mainNav">
            <div class="container">
                <a class="navbar-brand" href="#page-top">MENGTING LI</a>
                <button class="navbar-toggler text-uppercase font-weight-bold bg-primary text-white rounded" type="button" data-bs-toggle="collapse" data-bs-target="#navbarResponsive" aria-controls="navbarResponsive" aria-expanded="false" aria-label="Toggle navigation">
                    Menu
                    <i class="fas fa-bars"></i>
                </button>
                <div class="collapse navbar-collapse" id="navbarResponsive">
                    <ul class="navbar-nav ms-auto">
                        <li class="nav-item mx-0 mx-lg-1"><a class="nav-link py-3 px-0 px-lg-3 rounded" href="#home">Home</a></li>
                        <li class="nav-item mx-0 mx-lg-1"><a class="nav-link py-3 px-0 px-lg-3 rounded" href="#lab">Lab 1</a></li>
                    </ul>
                </div>
            </div>
        </nav>
        <!-- Masthead-->
        <header class="masthead bg-primary text-white text-center">
            <div class="container d-flex align-items-center flex-column">
                <!-- Masthead Heading-->
                <h1 class="masthead-heading text-uppercase mb-0">FAST ROBOTS</h1>
                <!-- Icon Divider-->
                <div class="divider-custom divider-light">
                    <div class="divider-custom-line"></div>
                    <div class="divider-custom-icon"><i class="fas fa-star"></i></div>
                    <div class="divider-custom-line"></div>
                </div>
                <!-- Masthead Subheading-->
                <p class="masthead-subheading font-weight-light mb-0"> This site displays the work I've completed in MAE4190: Fast Robots.</p>
            </div>
        </header>
        <!-- Portfolio Section-->
        <section class="page-section portfolio" id="portfolio">
            <div class="container">
                <!-- Portfolio Section Heading-->
                <h2 class="page-section-heading text-center text-uppercase text-secondary mb-0">Labs</h2>
                <!-- Icon Divider-->
                <div class="divider-custom">
                    <div class="divider-custom-line"></div>
                    <div class="divider-custom-icon"><i class="fas fa-star"></i></div>
                    <div class="divider-custom-line"></div>
                </div>
                <!-- Portfolio Grid Items-->
                <div class="row justify-content-center">
                    <!-- Portfolio Item 1-->
                    <div class="col-sm-3">
                        <div class="portfolio-item mx-auto" data-bs-toggle="modal" data-bs-target="#portfolioModal1">
                            <div class="portfolio-item-caption d-flex align-items-center justify-content-center h-100 w-100">
                                <div class="portfolio-item-caption-content text-center text-white"><i class="fas fa-plus fa-3x"></i></div>
                            </div>
                            <img class="img-fluid rounded mb-5" width="212" src="assets/img/lab1/artemis.jpeg" alt="..." />
                        </div>
                        <h5 class="text-center">Lab 1: Artemis</h5>
                    </div>
                    <!-- Portfolio Item 2 -->
                    <div class="col-sm-3">
                        <div class="portfolio-item mx-auto" data-bs-toggle="modal" data-bs-target="#portfolioModal2">
                            <div class="portfolio-item-caption d-flex align-items-center justify-content-center h-100 w-100">
                                <div class="portfolio-item-caption-content text-center text-white"><i class="fas fa-plus fa-3x"></i></div>
                            </div>
                            <img class="img-fluid rounded mb-5" width="212" src="assets/img/lab2/imu2.jpeg" alt="..." />
                            <h5 class="text-center">Lab 2: IMU</h5>
                        </div>
                    </div>
                    <!-- Portfolio Item 3-->
                    <div class="col-sm-3">
                        <div class="portfolio-item mx-auto" data-bs-toggle="modal" data-bs-target="#portfolioModal3">
                            <div class="portfolio-item-caption d-flex align-items-center justify-content-center h-100 w-100">
                                <div class="portfolio-item-caption-content text-center text-white"><i class="fas fa-plus fa-3x"></i></div>
                            </div>
                            <img class="img-fluid rounded mb-5" width="258" src="assets/img/lab3/tof.jpg" alt="..." />
                        </div>
                        <h5 class="text-center">Lab 3: TOF</h5>
                    </div>
                    <!-- Portfolio Item 4-->
                    <div class="col-sm-3">
                        <div class="portfolio-item mx-auto" data-bs-toggle="modal" data-bs-target="#portfolioModal4">
                            <div class="portfolio-item-caption d-flex align-items-center justify-content-center h-100 w-100">
                                <div class="portfolio-item-caption-content text-center text-white"><i class="fas fa-plus fa-3x"></i></div>
                            </div>
                            <img class="img-fluid rounded mb-5" width="266" src="assets/img/lab4/motor_driver.jpeg" alt="..." />
                        </div>
                        <h5 class="text-center">Lab 4: Motors and Open Loop Control</h5>
                    </div>
                    <!-- Portfolio Item 5-->
                    <div class="col-sm-3">
                        <div class="portfolio-item mx-auto" data-bs-toggle="modal" data-bs-target="#portfolioModal5">
                            <div class="portfolio-item-caption d-flex align-items-center justify-content-center h-100 w-100">
                                <div class="portfolio-item-caption-content text-center text-white"><i class="fas fa-plus fa-3x"></i></div>
                            </div>
                            <img class="img-fluid rounded mb-5" src="assets/img/lab5/PID.png" alt="..." />
                            <h5 class="text-center">Lab 5: PID Control</h5>
                        </div>
                    </div>
                    <!-- Portfolio Item 6-->
                    <div class="col-sm-3">
                        <div class="portfolio-item mx-auto" data-bs-toggle="modal" data-bs-target="#portfolioModal6">
                            <div class="portfolio-item-caption d-flex align-items-center justify-content-center h-100 w-100">
                                <div class="portfolio-item-caption-content text-center text-white"><i class="fas fa-plus fa-3x"></i></div>
                            </div>
                            <img class="img-fluid rounded mb-5" src="assets/img/lab5/PID.png" alt="..." />
                        </div>
                        <h5 class="text-center">Lab 6: Orientation PID Control</h5>
                    </div>
                </div>
            </div>
        </section>
        <!-- Footer-->
        <footer class="footer text-center">
            <div class="container">
                <div class="row">
                    <!-- Footer Location-->
                    <div class="col-lg-4 mb-5 mb-lg-0">
                        <h4 class="text-uppercase mb-4">Location</h4>
                        <p class="lead mb-0">
                            Cornell University
                            <br />
                            Ithaca, NY 14850
                        </p>
                    </div>
                    <!-- Footer Social Icons-->
                    <div class="col-lg-4 mb-5 mb-lg-0">
                        <h4 class="text-uppercase mb-4">Around the Web</h4>
                        <a class="btn btn-outline-light btn-social mx-1" href="https://www.linkedin.com/in/mengtingli1225/"><i class="fab fa-fw fa-linkedin-in"></i></a>
                    </div>
                    <!-- Footer About Text-->
                    <div class="col-lg-4">
                        <h4 class="text-uppercase mb-4">About Me</h4>
                        <p class="lead mb-0">
                            Hi! I'm Meng, an undergraduate senior majoring in mechanical engineering and minoring in computer science :)
                        </p>
                    </div>
                </div>
            </div>
        </footer>
        <!-- Portfolio Modals-->
        <!-- Portfolio Modal 1-->
        <div class="portfolio-modal modal fade" id="portfolioModal1" tabindex="-1" aria-labelledby="portfolioModal1" aria-hidden="true">
            <div class="modal-dialog modal-xl">
                <div class="modal-content">
                    <div class="modal-header border-0"><button class="btn-close" type="button" data-bs-dismiss="modal" aria-label="Close"></button></div>
                    <div class="modal-body text-center pb-5">
                        <div class="container">
                            <div class="row justify-content-center">
                                <div class="col-lg-8 mx-auto">
                                    <!-- Portfolio Modal - Title-->
                                    <h2 class="portfolio-modal-title text-secondary text-uppercase mb-0">LAB 1<h3 class="text-warning">Artemis</h3></h2>
                                    <!-- Icon Divider-->
                                    <div class="divider-custom">
                                        <div class="divider-custom-line"></div>
                                        <div class="divider-custom-icon"><i class="fas fa-star"></i></div>
                                        <div class="divider-custom-line"></div>
                                    </div>
                                    <!-- Portfolio Modal - Image-->
                                    <img class="img-fluid rounded mb-5" src="assets/img/lab1/artemis.jpeg" alt="..." />
                                    <!-- Portfolio Modal - Text-->
                                    <h3>PART I: GOAL</h3>
                                    <p class="text-left">The purpose of the first portion of this lab was to become acquainted with the Arduino IDE and the Artemis Nano microcontroller. This involved testing a few different functionalities of the Artemis board, including the LED light, the serial output, the temperature sensor, and the microphone. Since the Artemis board would be used as a microcontroller in future labs, it was imperative to understand it's design. </p>
                                    <h3>SETUP</h3>
                                    <ul style="list-style-type:none;">
                                      <li>The materials required for this lab include:</li>
                                      <li>1. A SparkFun RedBoard Artemis Nano</li>
                                      <li>2. A USB C-to-C or A-to-C cable</li>
                                      <li>3. The Arduino IDE, which can be installed from <a href="https://www.arduino.cc/en/software">here</a></li>
                                    </ul>
                                    <h3>EXAMPLE 1: Blink it Up</h3>
                                    <p>To test the LED on the board, a built-in example from the Arduino IDE was used. The code turned the LED light on for one second, then off for one second, repeatedly. The results are as shown in the video:</p>
                                    <div class="embed-container">
                                      <iframe width="480" height="300" src="https://www.youtube.com/embed/_RYOr5E5tyE" frameborder="0" allowfullscreen></iframe>
                                    </div>
                                    <p> </p>
                                    <h3>EXAMPLE 2: Serial</h3>
                                    <p>The second example involved testing the serial monitor output. The Arduino IDE was used to pass text inputs to the Artemis board, which would then be sent back to the serial monitor in the Arduino IDE from the microcontroller on the board.</p>
                                    <div class="embed-container">
                                      <iframe width="480" height="300" src="https://www.youtube.com/embed/4_aSxQzvBfo" frameborder="0" allowfullscreen></iframe>
                                    </div>
                                    <p></p>
                                    <h3>EXAMPLE 3: Analog Read</h3>
                                    <p>This example tested the temperature sensor on the Artemis board. The sample code sends data from the temperature sensor on the board to the serial monitor in the Arduino IDE. When the chip was blown on or heated up by hand, the temperature readings increased. In the video below, the temperature readings increased as I was blowing air onto the board. </p>
                                    <div class="embed-container">
                                      <iframe width="480" height="300" src="https://www.youtube.com/embed/qc5g7ligoZU" frameborder="0" allowfullscreen></iframe>
                                    </div>
                                    <p></p>
                                    <h3>EXAMPLE 4: Microphone Output</h3>
                                    <p>The last example tested the pulse density microphone (PDM) on the Artemis board. The built-in example from the Arduino IDE returns the highest frequency of sound captured. The video shows the micrphone capturing three "Hello"s said at different pitches.</p>
                                    <div class="embed-container">
                                      <iframe width="480" height="300" src="https://www.youtube.com/embed/LLHOArgsDcw" frameborder="0" allowfullscreen></iframe>
                                    </div>
                                    <p></p>
                                    <h3>PART 2: GOAL</h3>
                                    <p class="text-left"> The objective of the second portion of this lab as to set up the Bluetooth connection between the Artemis board and a computer. The Python code written for the Bluetooth connection would be used in the future labs.</p>
                                    <h3>SETUP</h3>
                                    <ul style="list-style-type:none;">
                                      <li>The materials required for this lab include:</li>
                                      <li>1. Python 3</li>
                                      <li>2. A virtual enviornment</li>
                                    </ul>
                                    <p>The virtual environment can be set up by running the following commands:<br>
                                    <code>
                                      python3 -m pip install --user virtualenv<br>
                                      python3 -m venv FastRobots_ble
                                    </code></p>
                                    <p>The virtual environment then needs to be activated and started in a Jupyter Server:<br>
                                    <code>
                                      source FastRobots_ble/bin/activate<br>
                                      pip install numpy pyyaml colorama nest_asyncio bleak jupyterlab<br>
                                      jupyter lab
                                    </code></p>
                                    <p>Once the Artemis board was connected to the computer, the first step was to update the Artemis MAC address. 
                                      This can be done by replacing the artemis_address value in the lab document with the MAC address printed by the Artemis board.
                                      By doing so, the Python code can now read the device through Bluetooth and connect to the Artemis board.
                                      Following this, a unique UUID address was generated to create a unique connection to my Artemis board, and not one of my classmate's boards. Because many of the Artemis boards used for this class share the same MAC address, it was possible for the Python code to connect to a different board. The generated UUID was used in the provided Python scripts to ensure a Bluetooth connection to my own board. An UUID was generated with the following code:<br>
                                      <code>
                                        from uuid import uuid4 <br>
                                        uuid4()
                                      </code>
                                    </p>
                                    <p>The Bluetooth connection was established, as shown:
                                      <img class="img-fluid rounded" src="assets/img/lab1/bluetooth.png" alt="..." />
                                    </p>
                                    <h3>TASK 1: ECHO</h3>
                                    <p>In developing a wireless debugging system, the first step was sending an ECHO command with a string value from the computer to the 
                                      Artemis board. The string would then be sent back to the Python code. 
                                      To achieve this, the ECHO command was defined as a command type in ble_arduino.ino and cmd_types.py.
                                      The Arduino code to perform the command: <br>
                                      <img class="img-fluid rounded" width="480" src="assets/img/lab1/echo.png" alt="..." />
                                    </p>
                                    <p>The Python code and the output:
                                      <img class="img-fluid rounded" src="assets/img/lab1/echo_py.png" alt="..." />
                                    </p>
                                    <h3>TASK 2: GET_TIME_MILLIS</h3>
                                    <p>The next step involved adding a command to get a timestamp. I used the Arduino function millis() to get the time in milliseconds. The new command GET_TIME_MILLIS was defined as a new command type in ble_arduino.ino and cmd_types.py, similar to the ECHO command. The Arduino code: <br>
                                      <img class="img-fluid rounded" width="450" src="assets/img/lab1/get_time_millis.png" alt="..." />
                                    </p>
                                    <p>The Python code and the output:
                                      <img class="img-fluid rounded" src="assets/img/lab1/get_time_millis_py.png" alt="..." />
                                    </p>
                                    <h3>TASK 3: Notification Handler</h3>
                                    <p>In writing a callback function, the Python code can gather data without calling the receive function. 
                                      A helper function was defined as the notification handler. When the notification handler is started, any changes from the
                                      Bluetooth device would be sent to the computer. Once it has been started and the command GET_TIME_MILLIS is sent,
                                      the most recent value for the timestamp would automatically be sent to the computer.
                                      The Python code and the output: <br>
                                      <img class="img-fluid rounded" src="assets/img/lab1/notifhandler.png" alt="..." />
                                    </p>
                                    <h3>TASK 4: GET_TIME_LOOP</h3>
                                    <p>To determine how fast messages are sent from the Artemis board, another command was written. The new command was defined as a new command type in ble_arduino.ino and cmd_types.py. When called, GET_TIME_LOOP runs a loop that gets the current time in milliseconds, which is sent and processed by the notification handler in the Python code. Timestamps were collected for a few seconds, which helps in determining how fast messages are sent. The Arduino code:<br>
                                      <img class="img-fluid rounded" width="450" src="assets/img/lab1/get_time_loop.png" alt="..." /><br>
                                      The Python code and the output:<br>
                                      <img class="img-fluid rounded" src="assets/img/lab1/loop_output.png" alt="..." /><br>
                                      By observing the output of the loop, the effective data transfer rate of this method is roughly 5 ms.
                                    </p>
                                    <h3>TASK 5: Timestamps Array</h3>
                                    <p>The next task involved creating an array capably of storing timestamps. This array was declared globally so that it could be 
                                      accessed by other functions. The command GET_TIME_LOOP was edited to insert each timestamp into the array, instead of immediately sending timestamps within a loop. Then, a new command, SEND_TIME_DATA, was created to iterate through the array and transmit each timestamp as a string to the computer for processing. A global variable, max_time_stamps, was created to determine the maximum number of time stamps to store. Additionally, num_time_stamps was declared to track the number of time stamps already stored in the array to prevent overfill.<br>
                                      The Arduino code: <br>
                                      <img class="img-fluid rounded" width="450" src="assets/img/lab1/send_time_data.png" alt="..." /><br>
                                      The Python code and the output:<br>
                                      <img class="img-fluid rounded" src="assets/img/lab1/send_time_py.png" alt="..." /><br>
                                    </p>
                                    <h3>TASK 5: Temperature Array</h3>
                                    <p>After storing a set of timestamps in an array, I initialized a second array that would store the temperature readings corresponding to each timestamp. Both arrays would be the same size. The command GET_TEMP_READINGS was used to iterate through both arrays concurrently, sending the temperature readings with its corresponding timestamp. The Arduino code: <br>
                                      <img class="img-fluid rounded" width="450" src="assets/img/lab1/get_temp_readings.png" alt="..." /><br>
                                      The Python code and the output:<br>
                                      <img class="img-fluid rounded" src="assets/img/lab1/get_temp_readings_py.png" alt="..." /><br>
                                    </p>
                                    <h3>DISCUSSION</h3>
                                    <p>Through this lab, I've learned about two methods of sending data: sending each data point individually vs. storing the data points in arrays and sending them in batches. While the first method allows for real-time data transfer and reduces memory usage, sending each timestamp individually incurred more overhead. By storing the data in arrays and sending them in batches, the overhead of establishing connections and sending data repeatedly is reduced. This also allows for higher throughput and better efficiency. However, using arrays can introduce latency if the array becomes too large or if the array is filling up. If real-time data transfer is crucial and low latency is required, the first method may be preferred due to its immediate data transmission. For applications with high throughput requirements, where sending data in batches can improve overall efficiency, the second method would be more suitable. The speed at which the second method can record data depends on several factors, but storing data in arrays and sending in batches can generally achieve relatively high recording speeds, especially in comparison to the first method with high data rates. Given that the Artemis board has 384 kB of RAM, the amount of data that can be stored without running out of memory depends on various factors such as the size of data elements and the overhead of data structures. With careful memory management, it should be possible to store thousands to tens of thousands of data points without exhausting the available memory.</p>
                                    <button class="btn btn-primary" data-bs-dismiss="modal">
                                        <i class="fas fa-xmark fa-fw"></i>
                                        Close Window
                                    </button>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <!-- Portfolio Modal 2-->
        <div class="portfolio-modal modal fade" id="portfolioModal2" tabindex="-1" aria-labelledby="portfolioModal2" aria-hidden="true">
            <div class="modal-dialog modal-xl">
                <div class="modal-content">
                    <div class="modal-header border-0"><button class="btn-close" type="button" data-bs-dismiss="modal" aria-label="Close"></button></div>
                    <div class="modal-body text-center pb-5">
                        <div class="container">
                            <div class="row justify-content-center">
                                <div class="col-lg-8">
                                    <!-- Portfolio Modal - Title-->
                                    <h2 class="portfolio-modal-title text-secondary text-uppercase mb-0">LAB 2<h3 class="text-warning">IMU</h3></h2>
                                    <!-- Icon Divider-->
                                    <div class="divider-custom">
                                        <div class="divider-custom-line"></div>
                                        <div class="divider-custom-icon"><i class="fas fa-star"></i></div>
                                        <div class="divider-custom-line"></div>
                                    </div>
                                    <!-- Portfolio Modal - Image-->
                                    <img class="img-fluid rounded mb-5" width="212" src="assets/img/lab2/imu2.jpeg" alt="..." />
                                    <!-- Portfolio Modal - Text-->
                                    <h3>GOAL</h3>
                                    <p>The purpose of this lab involved familiarizing ourselves with the IMU sensor and the RC car. We collected data from the accelerometer and the gyroscope on the sensor, which were then used to calculate information on the orientation and location of the car.
                                    </p>
                                    <h3>SETUP</h3>
                                    <ul style="list-style-type:none;">
                                        <li>The materials required for this lab include:</li>
                                        <li>1. An Artemis Nano board</li>
                                        <li>2. A 9DOF IMU sensor</li>
                                        <li>3. A Li-Ion 3.7V 850mAh battery</li>
                                        <li>4. A USB cable</li>
                                        <li>5. A Force1 RC car</li>
                                    </ul>
                                    <p>The image below shows the IMU sensor connected to the Artemis Nano board by a QWIIC connector.
                                        <img class="img-fluid rounded" width="200" src="assets/img/lab2/setup.jpeg" alt="..." />
                                    </p>
                                    <p>To ensure the connection of the sensor, an example from the IMU library was used. In the example code, the variable AD0_VAL represents the value of the last bit in the I2C address.For this case, AD0_VAL should be set to 0 since the ADR jumper is closed. In addition to this change, a chunk of code was added such that when the board started running,the LED on the board would blink three times. This served as a visual indicationthat would be helpful later in the lab. <br>
                                        The Arduino code, along with the Serial Monitor output:
                                        <img class="img-fluid rounded" src="assets/img/lab2/example.png" alt="..." />
                                    </p>
                                    <p>While observing the acceleration and gyroscope data, I noticed a few things: When the board is rotated, the gyroscope data changes according to the axes of rotation, while the accelerometer data doesn't change. As an example, when the board is rotated around the z-axis, there are changes on the gyroscope data for the z-axis. Flipping the board reflects the same results as rotating the board, but a more sudden change with the gyroscope. Accelerating the board results in changes in the accelerometer data. For example, accelerating the board forward results in an increase in acceleration along the x-axis. In summary, the gyroscope detects angular velocity around its axes, while the accelerometer detects linear acceleration along its axes.
                                    </p>
                                    <h3>ACCELEROMETER TASK 1</h3>
                                    <p>The accelerometer on the IMU can be useful in calculating the roll and pitch values, with the equations:<br>
                                        θ = pitch = tan<sup>-1</sup>(<sup>a<sub>x</sub></sup>/<sub>a<sub>z</sub></sub>) <br>
                                        ø = roll = tan<sup>-1</sup>(<sup>a<sub>y</sub></sup>/<sub>a<sub>z</sub></sub>) <br>
                                        After implementing these functions in Arduino, the pitch and roll data can be observed through the Serial Monitor and the Serial Plotter. The Serial Plotter output at {-90, 0, 90} degrees for pitch and roll:
                                        <div class="embed-container">
                                            <iframe width="480" height="300" src="https://youtube.com/embed/I-grgxpVEdg" frameborder="0" allowfullscreen></iframe>
                                        </div>
                                        The Serial Plotter displays the noisy nature of the accelerometer on the IMU. When looking at the ends of the plot, it looks like the accelerometer has determined the -90 degrees and 90 degrees accurately. Although at the end of the plot where it should be 90 degrees, the output was around 100 degrees. This may be due to human error, where I didn't exactly end the turn at 90 degrees. With this being said, a two-point calibration wasn't necessary.
                                    </p>
                                    <h3>ACCELEROMETER TASK 2</h3>
                                    <p>To analyze the noise in the frequency spectrum, the Fourier Transform was used. Using this <a href="https://www.arduino.cc/en/software">Python tutorial</a>, the accelerometer's pitch and roll data were plotted over the time domain, as well as the frequency domain. The output plots:<br>
                                        <img class="img-fluid rounded" width="300" src="assets/img/lab2/pitch_time.png" alt="..." />
                                        <img class="img-fluid rounded" width="300" src="assets/img/lab2/pitch_freq.png" alt="..." /> <br>
                                        <img class="img-fluid rounded" width="300" src="assets/img/lab2/roll_time.png" alt="..." />
                                        <img class="img-fluid rounded" width="300" src="assets/img/lab2/roll_freq.png" alt="..." /> <br>
                                        Analyzing the graphs, there isn't much noise in the IMU accelerometer data. Because there weren't any noticeable spikes or high amplitudes during low frequencies, a low-pass filter isn't needed. Since the low-pass filter has already been implemented on the IMU by default, there is no need for another one. <br>
                                    </p>
                                    <h3>ACCELEROMETER TASK 3</h3>
                                    <p>
                                        Although there wasn't much noise in the data, I applied a low-pass filter because the accelerometer will be more prone to noise while the car is closer in proximity. The cutoff frequency was determined by looking at the frequency spectrum, and determining a number that is below the frequencies of interest in the signal but above the frequencies containing most of the noise. The sample rate of the accelerometer affects the choice of cutoff frequency primarily due to the Nyquist frequency. The cutoff frequency should be chosen below the Nyquist frequency to avoid aliasing and accurately capture the signal's frequency content. When enough force was used to induce a vibration on the table, there were vibratonal noises, which led to additional high-frequency components to the accelerometer data. Consequently, the choice of cutoff frequency for the lowpass filter becomes crucial to effectively filter out this added noise while preserving the essential features of the signal.<br>
                                        The results show a smoother curve with the effects of noise significantly reduced:<br>
                                        <img class="img-fluid rounded" width="300" src="assets/img/lab2/lpf_data.png" alt="..." /> <br>
                                    </p>
                                    <h3>GYROSCOPE TASK 1</h3>
                                    <p>The gyroscope data can be used to calculate roll, pitch, and yaw values, with the equations:<br>
                                        ø = roll = ø + g<sub>x</sub> * dt<br>
                                        θ = pitch = θ + g<sub>y</sub> * dt<br>
                                        ψ = yaw = ψ + g<sub>z</sub> * dt<br>
                                        While playing around with the IMU, the Serial Plotter displays:
                                        <div class="embed-container">
                                            <iframe width="480" height="300" src="https://youtube.com/embed/AyggDPumNlE" frameborder="0" allowfullscreen></iframe>
                                        </div>
                                        The readings from the gyroscope displayed a drift over time, which may be due to integration errors. This means that the time delay increases as time passes. On the other hand, the gyroscope provided more accurate data during rapid movements or vibrations, mainly because the accelerometer readings are affected by inertial forces. While increasing the sampling frequency improves the accuracy on gyroscope readings by reducing the integration error over shorter time intervals, higher sampling frequencies may increase power consumption and processing load. To overcome the limitations of each sensor, a complimentary filter was used to compute pitch and roll values that are accurate and stable. The equations are:<br>
                                        θ = pitch = (θ + θ<sub>g</sub> * dt)(1 - α) + θ<sub>α</sub> * α<br>
                                        ø = roll = (ø + ø<sub>g</sub> * dt)(1 - α) + ø<sub>α</sub> * α<br>
                                        The choice of alpha represented the trade-off between response time and noise reduction. After changing the alpha value a few times and observing the changes in data, I settled with 0.2.<br>
                                        With the complementary filter:<br>
                                        <div class="embed-container">
                                            <iframe width="480" height="300" src="https://youtube.com/embed/7z5Dc329O7Q" frameborder="0" allowfullscreen></iframe>
                                        </div>
                                        The combined measurements from the accelerometer and gyroscope stability and accuracy, or at least more stable and more accurate than the measurements from each separately.
                                    </p>
                                    <h3>SAMPLE DATA</h3>
                                    <p>Following this, I took a few steps to speed up the execution time for the main loop. I made sure to check whether the IMU data was ready or not in every iteration of the main loop before storing the data into the array. I removed all delays and unnecessary Serial.print statements. With these improvements, the sampling rate is now 3ms for new data. The main loop on the Artemis is running faster than the IMU produces new values!  The Arduino code:<br>
                                        <img class="img-fluid rounded" width="550" src="assets/img/lab2/sample_data_arduino.png" alt="..." /> <br>
                                        The Python script and output:<br>
                                        <img class="img-fluid rounded" src="assets/img/lab2/sample_data_python.png" alt="..." /> <br>
                                    </p>
                                    <h3>RECORD A STUNT!</h3>
                                    <p>After mounting the 850 mAh battery on the bar and putting AA batteries into the remote, I played around with the RC car. As shown in the video below, the car seems very sensitive and hard to control. The car can flip if there's a sudden reverse in the opposite direction. Another thing to note was that the car moved at constant speeds, unable to slow down or speed up.
                                        <div class="embed-container">
                                            <iframe width="480" height="300" src="https://youtube.com/embed/5Kbe5es9SRM" frameborder="0" allowfullscreen></iframe>
                                        </div>
                                    </p>
                                    <button class="btn btn-primary" data-bs-dismiss="modal">
                                        <i class="fas fa-xmark fa-fw"></i>
                                        Close Window
                                    </button>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <!-- Portfolio Modal 3-->
        <div class="portfolio-modal modal fade" id="portfolioModal3" tabindex="-1" aria-labelledby="portfolioModal3" aria-hidden="true">
            <div class="modal-dialog modal-xl">
                <div class="modal-content">
                    <div class="modal-header border-0"><button class="btn-close" type="button" data-bs-dismiss="modal" aria-label="Close"></button></div>
                    <div class="modal-body text-center pb-5">
                        <div class="container">
                            <div class="row justify-content-center">
                                <div class="col-lg-8">
                                    <!-- Portfolio Modal - Title-->
                                    <h2 class="portfolio-modal-title text-secondary text-uppercase mb-0">LAB 3<h3 class="text-warning">TOF</h3></h2>
                                    <!-- Icon Divider-->
                                    <div class="divider-custom">
                                        <div class="divider-custom-line"></div>
                                        <div class="divider-custom-icon"><i class="fas fa-star"></i></div>
                                        <div class="divider-custom-line"></div>
                                    </div>
                                    <!-- Portfolio Modal - Image-->
                                    <img class="img-fluid rounded mb-5" width="250" src="assets/img/lab3/tof.jpg" alt="..." />
                                    <!-- Portfolio Modal - Text-->
                                    <h3>GOAL</h3>
                                    <p>The purpose of this lab is to familiarize ourselves with the Time of Flight (ToF) sensors, VL53L1X, which can be used to measure the distance away from an object. Two ToF sensors were attached to the RC car and used to collect data simultaneously. 
                                    </p>
                                    <h3>SETUP</h3>
                                    <ul style="list-style-type:none;">
                                        <li>The materials required for this lab include:</li>
                                        <li>1. An Artemis Nano board</li>
                                        <li>2. A USB cable</li>
                                        <li>3. Two 4m ToF sensors</li>
                                        <li>4. A QWIIC breakout board</li>
                                        <li>5. Two QWIIC connectors</li>
                                        <li>6. A ruler or graph paper</li>
                                    </ul>
                                    <h3>PRELAB</h3>
                                    <p>The two sensors share an I2C address of 0x52 by default, based on the VL53L1X datasheet.
                                    </p>
                                    <p>Because the address of a ToF sensor is hardwired on the board, the two sensors can't be accessed individually. There are two approaches to solving this issue. One approach is to keep the same address on the two sensors, but alternate between using each sensor through the program while both sensors are powered. An issue with this approach is the delay involved with turning sensors back on. Another option is to change the address of one sensor during setup, through the shutdown pins, so the Artemis can differentiate between the two. I went with the latter approach, and soldered the XSHUT pin of one sensor to GPIO 7 on the Artemis board. This way, the corresponding sensor can be shut off during setup and the address of the other sensor can be changed. Following this, the first sensor can be turned back on, and the two sensors can now work simultaneously with different addresses. 
                                    </p>
                                    <p>Given the range and angular sensivity of the ToF sensors, I've decided to place one in the front of the car and the other on one side of the car. The front sensor allows the RC car to detect obstacles directly in its path, allowing it to react promptly and avoid obstables while moving forward. With one sensor on the side of the car, there is limited coverage for obstacles that might approach from the side. Some scenarios where the car will miss obstacles include blind spots and obstacles that are close to it. When obstacles are in blind spots like the side of the car without the ToF sensor, or blind spots caused by a sharp turn, the obstacles will be missed until the car changes direction. Objects very close to the car's side might also be missed by the side sensor if its range doesn't extend far enough laterally. 
                                    </p>
                                    <p>The image below depicts the wiring diagram with two ToF sensors, an IMU sensor, a QWIIC breakout board, and the Artemis Nano board:<br>
                                        <img class="img-fluid rounded mb-5" src="assets/img/lab3/wiring_diagram.jpeg" alt="..." />
                                    </p>
                                    <h3>TASK 1: Connecting a ToF Sensor to the Artemis</h3>
                                    <p>To connect a ToF sensor to the Artemis board, I cut off one end of the QWIIC connector and soldered it to the sensor. By checking the QWIIC connector datasheet, one can determine that the red wire connects to VIN, black to GND, blue to SDA, and yellow to SCL. Then, the other end of the QWIIC connector is attached to the QWIIC breakout board, which is then connected to the Artemis board. The XSHUT pin was also soldered to GPIO 7 for later use.<br>
                                        <img class="img-fluid rounded mb-5" width="300" src="assets/img/lab3/one_tof_connected.JPG" alt="..." />
                                    </p>
                                    <h3>TASK 2: Artemis scanning for I2C device</h3>
                                    <p>By burning Example5_wire_I2C in Apollo3 examples, the Artemis detected a sensor with address 0x29, which is different from the expected 0x52. By observing the binary representation of 0x29 and 0x52, one can see that 0x29 is 0x52 bitshifted to the right. This is because the rightmost bit is used to indicate a read or write to the address.<br>
                                        <img class="img-fluid rounded mb-5" src="assets/img/lab3/i2c_address.png" alt="..." />
                                    </p>
                                    <h3>TASK 3: Three Modes of the ToF sensor</h3>
                                    <p>Time of Flight sensors offer three modes of operation to optimize ranging performance based on the maximum expected range. The short range mode is optimized for close-range detection and provides high accuracy and resolution within its range, but is limited in its detection range. The long range mode offers the maximum detection range, with reduced accuracy and resolution compared to shorter-range modes. This mode also involves longer measurement times, which may introduce delays in detecting nearby objects. The medium range mode offers a balance between detection range and accuracy. Considering the size of the car, the short mode is adequate. This can change later, as testing will better inform us of the needs of the car. 
                                    </p>
                                    <p>To test the accuracy of the ToF sensor in the short range mode, Example1_ReadDistance in Apollo3 examples was used. Since the default mode is the long range mode, a line was added to the setup code:<br>
                                        <code>distanceSensor.setDistanceModeShort();</code><br>
                                        50 measurements were taken with the ToF sensor at 30 mm, 60 mm, 90 mm, and 120 mm from a wall. The average of the 50 readings were then plotted against the actual, expected measurements, as shown below. The actual sensor deviates more and more from the expected as the distance increases, which means a decrease in accuracy. In terms of repeatability, the 50 measurements taken at each distance were relatively consistent, and even more so at shorter distances. The experiment was then repeated for a darker environment, which showed higher accuracy.<br>
                                        <img class="img-fluid rounded mb-5" width="350" src="assets/img/lab3/measurements_light.png" alt="..." />
                                        <img class="img-fluid rounded mb-5" width="350" src="assets/img/lab3/measurements_dark.png" alt="..." />
                                    </p>
                                    <h3>TASK 4: Two ToF Sensors</h3>
                                    <p>Both Time of Flight sensors are now ready to be wired to the Artemis board (based on the wiring diagram in the prelab)! As mentioned in the prelab, during setup, one sensor was turned off while the address of the other sensor was changed, and then turned back on. By doing so, the two sensors can now be recognized separately. The Setup code snippet: <br>
                                        <img class="img-fluid rounded" width="500" src="assets/img/lab3/setup_code.png" alt="..." /> <br>
                                        The output displays independent measurements from the two ToF sensors: <br>
                                        <img class="img-fluid rounded mb-5" width="300" src="assets/img/lab3/output_measurements.png" alt="..." />
                                    </p>
                                    <h3>TASK 5: ToF Sensor Speed</h3>
                                    <p>To determine the time it takes for the sensor to finish a measurement, a piece of code was written to print the Artemis clock time continuously, and the new ToF sensor data from both sensors only when available. The corresponding code and its output:<br>
                                        <img class="img-fluid rounded" src="assets/img/lab3/measurement_time.png" alt="..." /><br>
                                        <img class="img-fluid rounded" width="250" src="assets/img/lab3/measurement_time_output.png" alt="..." /><br>
                                        As seen from the output, it takes approximately 60 ms for the sensors to produce a distance measurement. Another thing to note is that the loop takes roughly 7 ms to execute without any measurements ready, and 11-12 ms with measurements to print. The main limiting factor is the internal delay of the sensor.
                                    </p>
                                    <br>
                                    <h3>TASK 6: Time v. Distance</h3>
                                    <p>The next step was to send these time-stamped ToF readings over Bluetooth to the computer, and analyze the data with a plot in Jupyter notebook. A new notification handler was written to receive the string from the Artemis, parse the string and store the values into three arrays, corresponding to the time, distance reading from sensor one, and distance reading from sensor two. The arrays were then used to generate a plot of the data with time on the x-axis and ToF data on the y-axis.<br>
                                        The resulting graph:<br>
                                        <img class="img-fluid rounded" width="400" src="assets/img/lab3/timevdistance.png" alt="..." /><br>
                                    </p>
                                    <button class="btn btn-primary" data-bs-dismiss="modal">
                                        <i class="fas fa-xmark fa-fw"></i>
                                        Close Window
                                    </button>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <!-- Portfolio Modal 4-->
        <div class="portfolio-modal modal fade" id="portfolioModal4" tabindex="-1" aria-labelledby="portfolioModal4" aria-hidden="true">
            <div class="modal-dialog modal-xl">
                <div class="modal-content">
                    <div class="modal-header border-0"><button class="btn-close" type="button" data-bs-dismiss="modal" aria-label="Close"></button></div>
                    <div class="modal-body text-center pb-5">
                        <div class="container">
                            <div class="row justify-content-center">
                                <div class="col-lg-8">
                                    <!-- Portfolio Modal - Title-->
                                    <h2 class="portfolio-modal-title text-secondary text-uppercase mb-0">LAB 4<h3 class="text-warning">Motor Driver and Open Loop Control</h3></h2>
                                    <!-- Icon Divider-->
                                    <div class="divider-custom">
                                        <div class="divider-custom-line"></div>
                                        <div class="divider-custom-icon"><i class="fas fa-star"></i></div>
                                        <div class="divider-custom-line"></div>
                                    </div>
                                    <!-- Portfolio Modal - Image-->
                                    <img class="img-fluid rounded mb-5" width="275" src="assets/img/lab4/motor_driver.jpeg" alt="..." />
                                    <!-- Portfolio Modal - Text-->
                                    <h3>GOAL</h3>
                                    <p>The purpose of this lab involved implementing control of RC car, using motor drivers and open loop control. By the end of the lab, the car could follow a set of pre-programmed moves, through the Artemis board and dual motor drivers.</p>
                                    <h3>PRELAB</h3>
                                    <p>There were a few factors to consider when mounting the motor drivers. First, for control on the Artemis board, I decided to use GPIO 15 and 16 for one motor, and GPIO 2 and 3 for the other. The main consideration in choosing these pins were their PWM capabilities. Then, the Artemis board and the motor drivers were powered with two separate batteries since using one battery would result in transient effects, which would reset the microcontroller. Using the same battery could also lead to noise from the motors that could affect the sensors attached to the Artemis board. With these factors in mind, I drew the following wiring diagram:<br>
                                        <img class="img-fluid rounded" src="assets/img/lab4/circuit_diagram.jpeg" alt="..." />
                                    </p>
                                    <h3>TASK 1: EXTERNAL POWER SUPPLY AND OSCILLOSCOPE</h3>
                                    <p>To verify the circuit connection, one dual motor driver was connected to an external power supply and an oscilloscope. To simulate conditions similar to the 850 mAh battery, the power supply was set to 3.7V (the voltage output of the battery). I forgot to take a picture of the oscilloscope setup while I was doing this, and I realized later, and took a picture of the setup for the next step, which was very similar. But basically, the power supply was used in place for the motor in my circuit diagram, and the oscilloscope was used connected to the corresponding GND and VIN pins on the motor driver.<br>
                                        <img class="img-fluid rounded" width="300" src="assets/img/lab4/setup.jpg" alt="..." />
                                    </p>
                                    <p>After setting up the connections, a PWM signal was generated to regulate the power on the motor driver output. analogWrite was used to generate a PWM input from the Artemis board, with one input of 0 and the other of 200. The PWM output on the oscilloscope and the corresponding code snippet:<br>
                                        <img class="img-fluid rounded" style="margin-right:20px" width="250" src="assets/img/lab4/oscillopscope_output.jpg" alt="..." />   
                                        <img class="img-fluid rounded" width="250" src="assets/img/lab4/oscilloscope_code.png" alt="..." /><br>
                                    </p>
                                    <h3>TASK 2: MOTOR TESTING</h3>
                                    <p>After unscrewing and removing the top of the car, I cut the LED wires, unmounted the PCB, and cut the wires connected to the PCB as close to the board as possible. With this, the car was taken apart. To test the motor drivers one at a time, they were soldered to one of the motors on the car. Still using the external power supply, the wheels were programmed to spin in both directions for 1 second each.<br>
                                        <div class="embed-container">
                                            <iframe width="480" height="300" src="https://youtube.com/embed/aU5CKZ9KGzQ" frameborder="0" allowfullscreen></iframe>
                                        </div>
                                        <img class="img-fluid rounded" width="250" src="assets/img/lab4/two_directions_code.png" alt="..." /><br>
                                    </p>
                                    <p>Then, the 850 mAh battery was attached and the wheels were tested again to ensure that the circuit works while being fully battery powered. The wheels were programmed to spin in one direction for a second, stop or slow down for a second, and then spin in the other direction for another second (all in a loop). The video below shows all of the wheels spinning correctly with the batteries attached.<br>
                                        <div class="embed-container">
                                            <iframe width="480" height="300" src="https://youtube.com/embed/86f-RTkLRXs" frameborder="0" allowfullscreen></iframe>
                                        </div>
                                        <img class="img-fluid rounded" width="250" src="assets/img/lab4/wheels_spinning_battery.png" alt="..." /><br>
                                    </p>
                                    <h3>TASK 3: RE-ASSEMBLING</h3>
                                    <p>After verifying the functionality of the motors, the car was put together with all the necessary components, as shown in the diagram below.<br>
                                        <img class="img-fluid rounded" width="300" src="assets/img/lab4/car_setup.jpeg" alt="..." /><br>
                                    </p>
                                    <h3>TASK 4: CALIBRATION</h3>
                                    <p>To test the range of the motors, I found the lower limit of the PWM value by decreasing the value until the car wasn't moving anymore. The last value at which the wheels moved is the lower limit in this case. Using the analogWrite function, the lower bound on the PWM was found to be around 30 for the left side, and around 40 for the right side. This meant that if the input values were constant for both sets of motors, then the car would be moving towards the left rather than in a straight line. Thus, a calibration factor had to be incorporated. The video below shows the car moving in a relatively straight line with a calibration factor of 1.375.<br>
                                        <div class="embed-container">
                                            <iframe width="480" height="300" src="https://youtube.com/embed/nZeZJjvk65A" frameborder="0" allowfullscreen></iframe>
                                        </div>
                                    </p>
                                    <h3>TASK 5: OPEN LOOP CONTROL</h3>
                                    <p>Demonstrating open loop control, the car was programmed to spin counter-clockwise, move forward, spin clockwise, and then move backward. The video, along with the corresponding code snippet is attached:<br>
                                        <div class="embed-container">
                                            <iframe width="480" height="300" src="https://youtube.com/embed/IEM2ng_C3RQ" frameborder="0" allowfullscreen></iframe>
                                        </div>
                                        <img class="img-fluid rounded" width="300" src="assets/img/lab4/open_loop_control.png" alt="..." /><br>
                                    </p>
                                    <button class="btn btn-primary" data-bs-dismiss="modal">
                                        <i class="fas fa-xmark fa-fw"></i>
                                        Close Window
                                    </button>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <!-- Portfolio Modal 5-->
        <div class="portfolio-modal modal fade" id="portfolioModal5" tabindex="-1" aria-labelledby="portfolioModal5" aria-hidden="true">
            <div class="modal-dialog modal-xl">
                <div class="modal-content">
                    <div class="modal-header border-0"><button class="btn-close" type="button" data-bs-dismiss="modal" aria-label="Close"></button></div>
                    <div class="modal-body text-center pb-5">
                        <div class="container">
                            <div class="row justify-content-center">
                                <div class="col-lg-8">
                                    <!-- Portfolio Modal - Title-->
                                    <h2 class="portfolio-modal-title text-secondary text-uppercase mb-0">LAB 5<h3 class="text-warning">Linear PID Control and Linear Interpolation</h3></h2>
                                    <!-- Icon Divider-->
                                    <div class="divider-custom">
                                        <div class="divider-custom-line"></div>
                                        <div class="divider-custom-icon"><i class="fas fa-star"></i></div>
                                        <div class="divider-custom-line"></div>
                                    </div>
                                    <!-- Portfolio Modal - Image-->
                                    <img class="img-fluid rounded mb-5" src="assets/img/lab5/PID.png" alt="..." />
                                    <!-- Portfolio Modal - Text-->
                                    <h3>GOAL</h3>
                                    <p>The purpose of this lab is to understand and implement PID control with the components already attached to the car, as well as implementing extrapolation.</p>
                                    <h3>PRELAB</h3>
                                    <p>To setup a system for testing and debugging the PID controller, a few bluetooth commands were set up between the Artemis and the computer. First, a command was added so that control values can be altered over bluetooth, since uploading new code to the Artemis board everytime a value is changed is time consuming, as shown below.<br>
                                        <img class="img-fluid rounded" width="300" src="assets/img/lab5/set_pid_values2.png" alt="..." /><br>
                                        Following this, another command was added to execute the PID controller over a fixed period of time, collect debugging data in arrays, and retrieve the arrays from the Artemis over Bluetooth. The data recorded includes the timestamps, the distance data from the front ToF sensor, and the PWM values.<br>
                                        <img class="img-fluid rounded" width="400" src="assets/img/lab5/pid_start.png" alt="..." /><br>
                                        In Python, the following procedure started the PID controller and received data over Bluetooth.<br>
                                        <img class="img-fluid rounded" src="assets/img/lab5/pid_py.png" alt="..." /><br>
                                    </p>
                                    <h3>TASK 1: Position Control</h3>
                                    <p>The goal was to have the car drive as fast as possible towards the wall and stop when it's 1 ft or 304 mm away from the wall. To do this, a function was written to calculate the speed at which the car should be going based on the PID controller values and the ToF sensor readings. The distance measured by the ToF sensor is used to calculate the difference between the target and current distance, which is the error. This error is then used to find the PWM values needed to spin the motors and the direction the car should move in (forward, backward, or stop when at target distance). This PWM value is clamped between 40 and 255 based on the range determined from Lab 4.<br>
                                        <img class="img-fluid rounded" width="400" src="assets/img/lab5/pid_func1.png" alt="..." /><br>
                                    </p>
                                    <h5>PID Values</h5>
                                    <p>I went for the simple P controller for its simplicity. Given that the range of motor input values is between 40 PWM and 255 PWM, and that the car can start anywhere from 2000 mm to 4000 mm from the wall, a reasonable range of the proportional controller can be evaluated. At the minimum possible speed and maximum possible distance, the  minimum Kp value would be 40/(4000-300)=0.0108. At the maximum possible speed and minimum possible distance, the maximum Kp value would be 255/(2000-300)=0.15. After trial and error, I found that a Kp value of 0.03 worked best for me. This value presented a balance between speed and overshoot.
                                    </p>
                                    <h5>Range and Sampling Time</h5>
                                    <p>For the ToF sensor to function within the range of 2-4 meters from the wall, I used the long distance mode on the sensor. To account for the relatively low sampling frequency of the ToF sensor, I implemented a range around the target distance from the wall (304 mm) where this target distance would be considered done. By recording the distance reading from the sensor only when new data is ready and only once in every loop by storing it in a variable, the sampling time is also decreased. Furthermore, I only sent all the data over with Bluetooth after the target has been reached, which removed overheads involved with sending data points over within the loop. With this, my sampling time was about 100 ms. This relatively large sampling time is directly proportional to the overshoot I am getting, but it's alright since the controller works.
                                    </p>
                                    <h5>Videos and Plots</h5>
                                    <p>Trial 1: Kp=0.03 on a smooth surface from roughly 2 meters (I don't have a measuring tape, sadly)
                                        <div class="embed-container">
                                            <iframe width="480" height="300" src="https://youtube.com/embed/CQmKdlTQQKo" frameborder="0" allowfullscreen></iframe>
                                        </div>
                                        <img class="img-fluid rounded" width="400" src="assets/img/lab5/1_distancevtime.png" alt="..." /><br>
                                        <img class="img-fluid rounded" width="400" src="assets/img/lab5/1_pwmvtime.png" alt="..." /><br>
                                    </p>
                                    <p>Trial 2: Kp=0.03 on a rough surface (carpet) from roughly 2 meters
                                        <div class="embed-container">
                                            <iframe width="480" height="300" src="https://youtube.com/embed/RbvKayy5PcM" frameborder="0" allowfullscreen></iframe>
                                        </div>
                                        <img class="img-fluid rounded" width="400" src="assets/img/lab5/2_distancevtime.png" alt="..." /><br>
                                        <img class="img-fluid rounded" width="400" src="assets/img/lab5/2_pwmvtime.png" alt="..." /><br>
                                    </p>
                                    <p>Trial 3: Kp=0.05 on a rough surface (carpet) from roughly 2 meters (visibly larger overshoots)
                                        <div class="embed-container">
                                            <iframe width="480" height="300" src="https://youtube.com/embed/_pf1N8w2uVE" frameborder="0" allowfullscreen></iframe>
                                        </div>
                                        <img class="img-fluid rounded" width="400" src="assets/img/lab5/3_distancevtime.png" alt="..." /><br>
                                        <img class="img-fluid rounded" width="400" src="assets/img/lab5/3_pwmvtime.png" alt="..." />
                                    </p>
                                    <p>Having implemented the simple proportional controller, there are definitely advantages to exploring the other ones involving integral and derivative control. The integral controller theoretically improves the steady-state accuracy, as the semi-squiggly steady-state plot represents some steady-state error in my trials. It will also allow for tigether control around the setpoint. The derivative controller can help improve stability and reduce overshoot by anticipating changes in error and dampening rapid fluctuations. I didn't have time to explore these, but they definitely seem worthwhile.
                                    </p>
                                    <h3>TASK 2: Extrapolation</h3>
                                    <p>As mentioned previously, the sampling rate was around 100 ms. This is the frequency at which the ToF sensor was returning distance measurements, and the rate at which the PID control loop was running. To decouple these two rates and enable the control loop to run faster, the control loop logic was changed so that the PID control was calculated during every loop, even if a distance reading isn't ready.</p>
                                    <h5>Faster Loop</h5>
                                    <p>The first step involved allowing the loop to calculate PID control values even if the ToF sensor doesn't have new readings. If a new datapoint isn't ready, then the previous measurement was used. To achieve this, the loop that checked for a new datapoint was edited, as shown below:<br>
                                        <img class="img-fluid rounded" width="300" src="assets/img/lab5/4_code.png" alt="..." /><br>
                                        With this, the rate of the loop has increased from 100 ms approximately 10 ms, as shown below. In comparison to the ToF sensor sampling rate, this is 10 times faster.
                                        <img class="img-fluid rounded" src="assets/img/lab5/4_timestamps.png" alt="..." /><br>
                                        Trial 4: Kp=0.03 on a rough surface (carpet) from roughly 2 meters, with faster control loop
                                        <div class="embed-container">
                                            <iframe width="480" height="300" src="https://youtube.com/embed/Nu75xjLY8Nc" frameborder="0" allowfullscreen></iframe>
                                        </div>
                                        <img class="img-fluid rounded" width="400" src="assets/img/lab5/4_distancevtime.png" alt="..." /><br>
                                        <img class="img-fluid rounded" width="400" src="assets/img/lab5/4_pwmvtime.png" alt="..." />
                                    </p>
                                    <h5>Extrapolator</h5>
                                    <p>The next step was to use an extrapolator. Instead of using an old datapoint to pass to the PID controller, an estimate for the car's distance from the wall was calculated with the two most recent readings from the sensor. The extrapolator function calculates the slope corresponding to the last two readings, and then estimates the current distance from the wall based on the amount of time that has passed since the last reading and the calculated slope. The following code snippet was used:
                                        <img class="img-fluid rounded" width="600" src="assets/img/lab5/5_code.png" alt="..." /><br>
                                        Trial 5: Kp=0.03 on a rough surface (carpet) from roughly 2 meters, with extrapolation
                                        <div class="embed-container">
                                            <iframe width="480" height="300" src="https://youtube.com/embed/M4b6wg07Y48" frameborder="0" allowfullscreen></iframe>
                                        </div>
                                        <img class="img-fluid rounded" width="400" src="assets/img/lab5/5_distance.png" alt="..." /><br>
                                        <img class="img-fluid rounded" width="400" src="assets/img/lab5/5_pwm.png" alt="..." />
                                    </p>



                                    <button class="btn btn-primary" data-bs-dismiss="modal">
                                        <i class="fas fa-xmark fa-fw"></i>
                                        Close Window
                                    </button>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <!-- Portfolio Modal 6-->
        <div class="portfolio-modal modal fade" id="portfolioModal6" tabindex="-1" aria-labelledby="portfolioModal6" aria-hidden="true">
            <div class="modal-dialog modal-xl">
                <div class="modal-content">
                    <div class="modal-header border-0"><button class="btn-close" type="button" data-bs-dismiss="modal" aria-label="Close"></button></div>
                    <div class="modal-body text-center pb-5">
                        <div class="container">
                            <div class="row justify-content-center">
                                <div class="col-lg-8">
                                    <!-- Portfolio Modal - Title-->
                                    <h2 class="portfolio-modal-title text-secondary text-uppercase mb-0">LAB 6<h3 class="text-warning">Orientation PID Control</h3></h2>
                                    <!-- Icon Divider-->
                                    <div class="divider-custom">
                                        <div class="divider-custom-line"></div>
                                        <div class="divider-custom-icon"><i class="fas fa-star"></i></div>
                                        <div class="divider-custom-line"></div>
                                    </div>
                                    <!-- Portfolio Modal - Image-->
                                    <img class="img-fluid rounded mb-5" src="assets/img/lab5/PID.png" alt="..." />
                                    <!-- Portfolio Modal - Text-->
                                    <p class="mb-4">We have not gotten to this lab yet :(</p>
                                    <button class="btn btn-primary" data-bs-dismiss="modal">
                                        <i class="fas fa-xmark fa-fw"></i>
                                        Close Window
                                    </button>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <!-- Bootstrap core JS-->
        <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.2.3/dist/js/bootstrap.bundle.min.js"></script>
        <!-- Core theme JS-->
        <script src="js/scripts.js"></script>
        <!-- * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *-->
        <!-- * *                               SB Forms JS                               * *-->
        <!-- * * Activate your form at https://startbootstrap.com/solution/contact-forms * *-->
        <!-- * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *-->
        <script src="https://cdn.startbootstrap.com/sb-forms-latest.js"></script>
    </body>
</html>
